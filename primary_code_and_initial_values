import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import Image, display
from tqdm.notebook import tqdm

# Constants for simulation
G = 1  # Gravitational constant
N = 100
mass_star = 1/N # Mass of each star (kg)
dt = 0.01  # Time step (seconds)
T_max = 10

def center_of_mass(positions):
    return np.sum(positions, axis=0) / N

# Initial positions and velocities
np.random.seed(42)
positions = np.random.uniform(-1, 1, size=(N, 2))
velocities = np.zeros((N,2))  # np.random.uniform(-1, 1, size=(N, 2))

# Go to center of mass
positions = positions - center_of_mass(positions)[None, :]
print('center of mass = ', center_of_mass(positions))

# Function to compute the gravitational forces on each star
def compute_forces(pos):
    forces = np.zeros_like(pos)
    for i in range(N):
        for j in range(i + 1, N):
            r = pos[j] - pos[i]
            r_magnitude = np.linalg.norm(r)
            if r_magnitude > 0:
                force_mag = G * mass_star**2 / r_magnitude**2
                force_dir = r / r_magnitude
                force = force_mag * force_dir
                forces[i] += force
                forces[j] -= force
    return forces

# Function to update positions and velocities of stars
def update(positions, velocities):
    positions = positions.copy()
    velocities = velocities.copy()
    
    forces = compute_forces(positions)
    accelerations = forces / mass_star
    velocities += accelerations * dt
    positions += velocities * dt
    return positions, velocities

saved_positions = []
saved_velocities = []
for i in tqdm(range(int(T_max // dt))):
    saved_positions.append(positions)
    saved_velocities.append(velocities)

    positions, velocities = update(positions, velocities)
